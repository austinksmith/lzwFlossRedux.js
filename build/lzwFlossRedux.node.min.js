module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(1);


/***/ }),
/* 1 */
/***/ (function(module, exports) {

	/* jshint esversion: 6, curly: true, eqeqeq: true, forin: true */
	
	/***********************************************************************************
	* Title: lzwFlossRedux                                                             *
	* Description: 100% Vanilla Javascript Multithreaded LZW Compression Library       *
	* Author: Austin K. Smith                                                          *
	* Contact: austin@asmithdev.com                                                    *  
	* Copyright: 2015 Austin K. Smith - austin@asmithdev.com                           * 
	* License: Artistic License 2.0                                                    *
	***********************************************************************************/
	
	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var lzwFlossReduxjs = function () {
	
	  /**
	  * @constructor
	  * @function constructor - Sets properties for this class
	  */
	  function lzwFlossReduxjs() {
	    _classCallCheck(this, lzwFlossReduxjs);
	
	    this.version = '1.0.0';
	    this.encode = this.lzwEncode;
	    this.decode = this.lzwDecode;
	  }
	
	  /**
	  * @description: Generates a thread and lzw encodes the supplied string
	  * @method encode
	  * @param {string} inputString
	  * @param {function} onSuccess
	  */
	
	
	  _createClass(lzwFlossReduxjs, [{
	    key: 'lzwEncode',
	    value: function lzwEncode(inputString) {
	      var _this = this;
	
	      return new Promise(function (resolve, reject) {
	        _this.run(inputString, _this.encodeString, resolve, reject, false);
	      });
	    }
	
	    /**
	    * @description: Generates a thread and decodes the supplied lzw encoded string
	    * @method decode
	    * @param {string} inputString
	    * @param {function} onSuccess
	    */
	
	  }, {
	    key: 'lzwDecode',
	    value: function lzwDecode(inputString) {
	      var _this2 = this;
	
	      return new Promise(function (resolve, reject) {
	        _this2.run(inputString, _this2.decodeString, resolve, reject, true);
	      });
	    }
	
	    /**
	    * @description: Abstracts hamsters usage for reusability
	    * @method run
	    * @param {string} inputString
	    * @param {function} encodeOrDecode
	    * @param {function} onSuccess
	    */
	
	  }, {
	    key: 'run',
	    value: function run(inputString, fn, onSuccess, onError, decode) {
	      var _inputString = decode ? inputString : unescape(encodeURIComponent(inputString));
	      var stringArray = this.splitString(inputString);
	      var params = {
	        array: stringArray
	      };
	      hamsters.promise(params, fn).then(function (output) {
	        var _output = output.data[0];
	        if (decode === true) {
	          _output = decodeURIComponent(escape(_output));
	        }
	        onSuccess(_output);
	      }).catch(function (error) {
	        onError(error);
	      });
	    }
	
	    /**
	    * @description: Splits a string into a charcode array
	    * @method splitString
	    * @param {string} inputString
	    */
	
	  }, {
	    key: 'splitString',
	    value: function splitString(inputString) {
	      var inputArray = (inputString + "").split("");
	      var outputArray = [];
	      for (var i = 0; i < inputArray.length; i++) {
	        outputArray.push(inputArray[i].charCodeAt(0));
	      }
	      return outputArray;
	    }
	
	    /**
	    * @description: Function to be executed within a thread to encode a string
	    * @method encodeString
	    * @param {params} Object
	    */
	
	  }, {
	    key: 'encodeString',
	    value: function encodeString() {
	      var returnCharacterCode = function returnCharacterCode(phrase) {
	        if (phrase.length > 1) {
	          return dictionary[phrase];
	        }
	        return phrase.charCodeAt(0);
	      };
	      var stringArray = [];
	      var n = 0;
	      for (n; n < params.array.length; n++) {
	        stringArray[n] = String.fromCharCode(params.array[n]);
	      }
	      var currentCharacter;
	      var output = [];
	      var dictionary = {};
	      var code = 256;
	      var phrase = stringArray[0];
	      var phrasePlusChar;
	      var i = 1;
	      for (i; i < stringArray.length; i++) {
	        currentCharacter = stringArray[i];
	        phrasePlusChar = dictionary[phrase + currentCharacter];
	        if (phrasePlusChar) {
	          phrase += currentCharacter;
	        } else {
	          output.push(returnCharacterCode(phrase));
	          dictionary[phrase + currentCharacter] = code;
	          code++;
	          phrase = currentCharacter;
	        }
	      }
	      output.push(returnCharacterCode(phrase));
	      for (i = 0; i < output.length; i++) {
	        rtn.data[i] = String.fromCharCode(output[i]);
	      }
	      rtn.data = rtn.data.join("");
	    }
	
	    /**
	    * @description: Function to be executed within a thread to decode an already encoded string
	    * @method decodeString
	    * @param {params} Object
	    */
	
	  }, {
	    key: 'decodeString',
	    value: function decodeString() {
	      var returnPhrase = function returnPhrase(currentCode, oldPhrase, currentCharacter) {
	        if (typeof dictionary[currentCode] !== 'undefined') {
	          return dictionary[currentCode];
	        }
	        return oldPhrase + currentCharacter;
	      };
	      var stringArray = [];
	      var n = 0;
	      for (n; n < params.array.length; n++) {
	        stringArray[n] = String.fromCharCode(params.array[n]);
	      }
	      var currentCharacter = stringArray[0];
	      var oldPhrase = currentCharacter;
	      var code = 256;
	      var currentCode;
	      var currentPhrase;
	      var dictionary = {};
	      rtn.data.push(currentCharacter);
	      for (var i = 1; i < stringArray.length; i++) {
	        currentCode = params.array[i];
	        if (currentCode < 256) {
	          currentPhrase = stringArray[i];
	        } else {
	          currentPhrase = returnPhrase(currentCode, oldPhrase, currentCharacter);
	        }
	        rtn.data.push(currentPhrase);
	        currentCharacter = currentPhrase.charAt(0);
	        dictionary[code] = oldPhrase + currentCharacter;
	        oldPhrase = currentPhrase;
	        code++;
	      }
	      rtn.data = rtn.data.join("");
	    }
	  }]);
	
	  return lzwFlossReduxjs;
	}();
	
	var lzwFlossRedux = new lzwFlossReduxjs();
	
	if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {
	  module.exports = lzwFlossRedux;
	}

/***/ })
/******/ ]);
//# sourceMappingURL=lzwFlossRedux.node.min.js.map